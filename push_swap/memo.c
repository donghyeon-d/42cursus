quick_sort(stack_a, stack_b, len)
{
	int cnt_pa;
	int cnt_pb;

	cnt_pb = 0
	if (stack_a->curr_cnt < 4)
		small_sort
	else if (stack_a->curr_cnt < 6)
	{
		pb
		pb
		small_sort_b
		small_sort
	}
	else
	{
		if (!issroted(stack_a), stack_a->curr_cnt))
			cnt_pb = qb(stack_a, stack_b, len);
		if (!issroted(stack_a), stack_a->curr_cnt))
			quick_sort(stack_a, stack_b, stack_a->curr_cnt);
		if (cnt_pb == 0)
			cnt_pa = qa(stack_a, stack_b, stack_b->curr_cnt);
		else
			cnt_pa = qa(stack_a, stack_b, cnt_pb);
	}
}

int quick_b(t_stack *stack_a, t_stack *stack_b, int len)
{
	어레이 만들기
	피벗 설정
	while (len)
		피벗에 따라 3등분으로 쪼개주기
	//if (!issorted(stack_a, stack_a->curr_cnt)
	//	ra만큼 rra해줌
	if (!issorted(stack_a, ra))
		quick_sort(t_stack *stack_a, t_stack *stack_b, ra)
	free(어레이)
	return (pb)
}

int	quick_a(t_stack *stack_a, t_stack *stack_b, int len)// len = qb하면서 pa한 횟수
{
	어레이 만들기
	피벗 설정
	while(len)
		피벗에 따라 3등분으로 쪼개주기
	if (!issroted(stack_a, pa - ra)
}